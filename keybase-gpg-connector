#!/usr/bin/python3
import sys
import os
import shutil
import subprocess
from typing import (
    List,
    Optional
)
import time

# Git's docs say that they call ``gpg -bsau $key``, but really they call
# ``gpg --status-fd 2 -bsau $key``. What they heck does all that mean, anyway?
#   -b, --detach-sign: make a detached signature
#   -s, --sign: sign a message
#   -a, --armor: create ascii armored output
#   -u, --local-user USER-ID: use USER-ID to sign or decrypt
#   --status-fd 2: write status headers to stderr; see
#       our get_gnupg_status_headers for more details

KEYBASE_BIN = "keybase.exe"
if os.getenv('HARBOUR_USE_GNUPG2'):
    USE_GNUPG2 = True
else:
    USE_GNUPG2 = False

def get_fingerprint_from_id(key_id: str) -> Optional[str]:
    """Returns the first full fingerprint of a PGP key identified by the ID.

    When you run ``keybase pgp list`` the output that comes back has a "PGP
    Fingerprint" where the last 16 digits should match the ID that comes from
    ``keybase pgp export``.

    Arguments:
        key_id {str} -- the short ID of the PGP key you want a fingerprint of
    """
    fingerprint: str = None
    list_proc = subprocess.Popen(
        [KEYBASE_BIN, "pgp", "list"],
        universal_newlines=True,
        stdout=subprocess.PIPE
    )
    key_lower = key_id.lower()

    # We're looking for a line that's written line this:
    # PGP Fingerprint: {FINGERPINT}
    for line in list_proc.stdout:
        match_str = "PGP Fingerprint: ".lower()
        line_clean = line.strip().lower()

        if line_clean.startswith(match_str) and line_clean.endswith(key_lower):
            # Upper case to match gnupg2's behaviour
            fingerprint = line_clean.split(match_str)[1].upper()
            break
    
    return fingerprint


def get_gnupg_status_headers(key_id: str) -> Optional[str]:
    """Returns gnupg2-like status-fd output required for Git to accept the PGP
    signature.

    For more deatils, see gnupg2's doc/DETAILS file (https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=tree;f=doc;h=141111413578a55231976f11aed4639ad6879679;hb=refs/heads/master)
    and git's source code (https://github.com/git/git/blob/3bab5d56259722843359702bc27111475437ad2a/gpg-interface.c),

    Arguments:
        key_id {str} -- the key ID used to sign the message
    
    Returns:
        headers {str} -- status headers for output, using gnupg2's standard
    """

    fingerprint = get_fingerprint_from_id(key_id)
    if not fingerprint:
        return None
    
    # TODO: Do less faking on these headers
    status_headers = [
        # f"[GNUPG:] KEY_CONSIDERED {get_fingerprint_from_id(key_id)}\n",
        f"[GNUPG:] KEY_CONSIDERED {get_fingerprint_from_id(key_id)} 2\n",
        # "[GNUPG:] BEGIN_SIGNING H10\n",
        "[GNUPG:] BEGIN_SIGNING\n",
        # f"[GNUPG:] SIG_CREATED D 1 10 00 {int(time.time())} {get_fingerprint_from_id(key_id)}\n"
        # SIG_CREATED <type> <pk_algo> <hash_algo> <class> <timestamp> <key_fingerprint>
        # Type is D for "detached", pk_algo is "1" for RSA+RSA
        # (see "Algorithm names for the "keygen.algo" prompt" in gnupg2
        # doc/DETAILS), hash_algo and class both come from one time I ran gpg2.
        # Documentation is unclear `why` they have these values.
        f"[GNUPG:] SIG_CREATED D 1 10 00 {int(time.time())} {get_fingerprint_from_id(key_id)}\n"
    ]

    return ''.join(status_headers)


def get_fake_gnupg_sign_status(key_id: str) -> Optional[str]:
    pass


def get_fake_gnupug_verify_status() -> Optional[str]:
    """Returns a GNUPG-like string that Git can interpet as a "good signature".
    """
    return """\n[GNUPG:] GOODSIG \n"""

def try_gpg2(args: List[str]) -> None:
    input_file = sys.argv[-2]
    message = ''.join(sys.stdin.readlines())
    gpg2_process = subprocess.Popen(
        ["gpg", "--status-fd", "1", "--keyid-format", "long", "--verify", input_file, "-"],
        stdin=subprocess.PIPE,
        stderr=subprocess.PIPE,
        encoding='utf-8'
    )
    # All output goes to stderr no matter what
    _, out = gpg2_process.communicate(input=message)
    out = out.replace("\n\r", "n")[:-1]
    print(out, file=sys.stderr, flush=True)
    exit(gpg2_process.returncode)

def handle_error(error_output: str, returncode: int) -> Optional[str]:
    if "signature made by unknown entity" in error_output:
        return "Keybase was unable to verify the signature: the public key is unknown.\n" +\
                "To verify with your gnupg2 keychain, set HARBOUR_USE_GNUPG2 in your shell."


def verify(args: List[str]) -> None:
    open("log.txt", "a").write(f"verifying:\n{sys.argv}\n")
    input_file = sys.argv[-2]
    message = ''.join(sys.stdin.readlines())

    with open("log.txt", "a") as file:
        file.write("::::\n")
        file.write(message)
        file.write("\n::::\n")
        file.write(''.join(open(input_file, "r").readlines()))
        file.write("\n::::\n")

    keybase_process = subprocess.Popen(
        [KEYBASE_BIN, "pgp", "verify", "--detached", input_file, "--infile", "-"],
        # ["gpg", "--status-fd", "1", "--keyid-format", "long", "--verify", input_file, "-"],
        stdin=subprocess.PIPE,
        # stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        encoding='utf-8'
    )
    # All output goes to stderr no matter what
    _, out = keybase_process.communicate(input=message)

    if "Signature verified." not in out:
        if USE_GNUPG2:
            try_gpg2(args)
        else:
            err_msg = handle_error(error_output=out, returncode=keybase_process.returncode)
            print(err_msg, file=sys.stderr, flush=True)
            exit(keybase_process.returncode)

    # remove last newline
    out = "Keybase: " + out.replace(' (', '\n(').replace("\n\r", "n")[:-1]
    print(get_fake_gnupug_verify_status(), file=sys.stdout, flush=True)
    # print(f"Your errs: {errs}", flush=True)

    print(out, file=sys.stderr, flush=True)


def sign(args: List[str]) -> None:
    key = args[args.index("-bsau") + 1]

    message = ''.join(sys.stdin.readlines())
    keybase_process = subprocess.Popen(
        [KEYBASE_BIN, "pgp", "sign", "--detached", "-k", key],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        encoding='utf-8'
    )
    outs, errs = keybase_process.communicate(input=message)
    # remove last newline
    outs = outs.replace("\n\r", "n")[:-1]

    # Dear git,
    # what the fuck
    print(get_gnupg_status_headers(key), file=sys.stderr, flush=True)

    print(outs, flush=True)


def no_valid_func(*args, **kwargs) -> None:
    print("Not a valid operation", file=sys.stderr)


func: callable = no_valid_func

for arg in sys.argv:
    if (arg == '-bsau'):
        func = sign
    elif (arg == "--verify"):
        func = verify
    else:
        continue

func(sys.argv)